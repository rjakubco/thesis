%% Load document class fithesis2
%% {10pt, 11pt, 12pt}
%% {draft, final}
%% {oneside, twoside}
%% {onecolumn, twocolumn}
\documentclass[12pt,final,oneside]{fithesis2}

%% Basic packages
\usepackage[english]{babel}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}



%% Additional packages for colors, advanced
%% formatting options, etc.
\usepackage{color}
\usepackage{microtype}
\usepackage{url}
\usepackage{cslatexquotes}
\usepackage{fancyvrb}
\usepackage[small,bf]{caption}
\usepackage[plainpages=false,pdfpagelabels,unicode]{hyperref}
\usepackage[all]{hypcap}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}

%% Fix long URLs in DVIs
\usepackage{ifpdf}

%% Source code highlight

\usepackage{floatrow}
\usepackage[chapter]{minted}
\usemintedstyle{trac}
%get caption above code
\floatsetup[listing]{style=Plaintop}
%caption style    
%\captionsetup[listing]{format=listing, singlelinecheck=false, margin=pt, font={bf}}
%\captionsetup[listing]{format=listing}
%fancyvrb frame
\renewcommand{\listingscaption}{Example}


\DeclareGraphicsExtensions{.pdf,.png,.jpg}

\ifpdf
\else
  \usepackage{breakurl}
\fi

%% Packages used to generate various lists
\usepackage{makeidx}
\makeindex

\usepackage[xindy]{glossaries}
\makeglossary

%% Use STAR and CIRCLE signs for nested
%% itemized lists
\renewcommand{\labelitemii}{$\star$}
\renewcommand{\labelitemiii}{$\circ$}

%% Title page information
\thesistitle{RESTEasy integration with Apache Camel project}
\thesissubtitle{Master's thesis}
\thesisstudent{Roman Jakubčo}
\thesiswoman{false} %% Important when using Slovak or Czech lang
\thesisfaculty{fi}  %% {fi, eco, law, sci, fsps, phil, ped, med, fss}
\thesislang{en}     %% {en, sk, cs}
\thesisyear{Spring 2015}
\thesisadvisor{Mgr. Marek Grác, PhD.}

%% Beginning of the document
\begin{document}

%% Front page with a logo and basic thesis information
\FrontMatter
\ThesisTitlePage

%% Thesis declaration (required)
\begin{ThesisDeclaration}
  \DeclarationText
  \AdvisorName
\end{ThesisDeclaration}

%% Thanks (optional)
\begin{ThesisThanks}
I would like to thank to my supervisors RNDr. Adam Rambousek and Mgr. Marek Grác, Ph.D
for providing constant feedback during the preparation of this master’s
thesis. Many thanks goes to all my colleagues and friends from Red Hat that
expressed their valuable thoughts and helped to make this thesis better.

I would also like to thank to my parents and sister for standing behind me the whole time and bear with me and my personality.
\end{ThesisThanks}

%% Abstract (required)
\begin{ThesisAbstract}
The purpose of this master’s thesis is to design and develop new Camel
component by integrating two open-source project Apache Camel and
RESTEasy. This new component will act as RESTful web service in
the Camel integration framework.
\end{ThesisAbstract}

%% Keywords (required)
\begin{ThesisKeyWords}
Apache Camel, RESTEasy, JAX-RS, REST, RESTful, integration framework, component, web service

\end{ThesisKeyWords}

%% Beginning of the thesis itself
\MainMatter

%% TOC (required)
\tableofcontents

%% Thesis text structured using
%% chapters, sections, subsections, etc.
\chapter{Introduction}
The age we are living right now is also called Information Age, given that we can't even imagine our lives without modern technologies. They really makes our lives much more easier and the most important part is that they are providing us with crucial information. New technologies arise almost every day as IT segment is much more faster, innovative and agile than other segments. Creating new systems from scratch is very costly and almost never successful. More effective and better alternative is to assemble new systems from existing and proven components. There are various information systems and technologies based on various programming languages containing a lot of information. So it is no surprise that, there is a need for connecting these systems together and benefit from their already running code to provide business logic. It sounds really nice and simple, but the differences in technologies and programming languages create a real problem in integration between these systems. Also not every system is ready to be connected to others systems, because it doesn't provide the right interface. These are the problems that integration frameworks are trying to solve.

Integration frameworks are trying to enable interoperability across platforms, data formats, programming languages, different interfaces and make it simple as much as possible. Integration is hard and difficult, so frameworks are trying to find a way to make it straightforward and bring some real benefits for users when using them rather than intimidate them with hard learning process.

One of the more well-known integration frameworks is Apache Camel project\cite{camel-web}. Its main benefits are that it is open source project, developed under Apache with strong and helping community. Camel was design to keep up with new emerging technologies by creating modular project. The core is lightweight and stable. The framework is also providing necessary tools for every integration scenario. One of the features of Camel  based on its modularity is that, new communication protocols are added to the Camel as new components. This helps with keeping core lightweight. 

The main purpose of this thesis is to create a new Camel component. This component should integrate RESTEasy project\footnote{\url{http://resteasy.jboss.org/}} into the Camel. RESTEasy is open source project that provides various frameworks for building RESTful Web Services and RESTful Java applications. This component was required though community process as a new feature. There are of course other components already providing RESTful services in Camel distribution, so it may not be clear why there is a need for another similar component. RESTEasy is really popular RESTful implementation in JBoss community. It is also primarily used in WildFly application server in which can be this new component very useful.

Camel's community has a specified rule for naming the new component, so to follow this rule the component developed in this thesis is named Camel Resteasy.

Quick overview of thesis is as follows. It is divided into five thematic parts. The first chapter
contains introduction, motivation and purpose of the thesis.

The second chapter introduces all the technologies used in the implementation. The text tries to provide the most important facts and information about described technologies with links to more detailed sources for further reading.

The third chapter describes analysis and design. It contains diagrams to better illustrate how the new component works inside of Camel.

The next chapter describes implementation of the new component created for this thesis. It provides basic description of classes and their purpose. It also explains some specific problems and features of developed component.

The last chapter is conclusion of the work.


\chapter{Technologies}\label{tech}
This chapter describes technologies that are used for implementation of Camel RESTEasy  component. Each subsection introduces the technology and tries to explain what is its main functionality and common usage.

\section{Apache Camel}
Apache Camel is a open source rule-based routing and mediation framework implemented in Java. It is based on theory of Enterprise Integration Patterns or EIP, described in the book with same name written by Gregor Hohpe and Bobby Wolf\cite{eip}.

Its main focus is on integration and interaction between various applications or systems for which Camel can provide standalone routing, transformation, monitoring and many other things. From this point of view Camel may seems like ESB\footnote{ESB - Enterprise Service Bus}, but this is not the case, because Camel doesn't provide a container support or reliable message bus, but it can be deployed into one and create full integration platforms(also know as ESB) like Apache ServiceMix\footnote{\url{http://servicemix.apache.org/}}, JBoss Fuse\footnote{\url{http://www.jboss.org/products/fuse/overview/}} and JBoss Fuse Service Works. 

Camel also has extensible and modular architecture that allows implementation and seamlessly plug in support for new protocols. This architectural design makes Camel lightweight, fast and easy extendable for developers.\cite{camel-in-action}

\subsection{The core features}
Camel is using convention over configuration approach to describe given task by domain-specific language (DSL) in declarative way. This way Camel minimize number of lines of the source code that are needed for implementation of integration scenarios. Another key feature helping with this task is usage of theory of EIPs, which are already integrated in DSL and getting the most from their potential. 

Another fundamental principle of Camel is that it makes no assumptions about the data format. This feature is important because it makes possible for developers to integrate systems together, without any need to convert data to some canonical format. This way there are no limitations for integrating together any kind of systems\cite{camel-in-action}.

\subsection*{Routing and mediation engine}
One of the core features of Camel is its routing and mediation engine. A routing engine selectively moves a data from one destination to another based on the route's configuration. Users also can define their own rules for routing, add processors to modify the data, filter them based on some predicate and at the end decide the final destination for the delivery.

\subsection*{Enterprise integration patterns}
As mentioned before, Camel is based primarily on EIPs. EIPs describe integration problems and their solutions. They also provide some basic vocabulary, but the problem is the vocabulary isn't formalized. Into this comes Camel with its language which describes integration solutions and tries to formalized the vocabulary. There's almost a one-to-one relationship between patterns described in
Enterprise Integration Patterns and the Camel DSL\footnote{\url{http://camel.apache.org/enterprise-integration-patterns.html}}.

Almost all of EIPs, that are defined in the book, are implemented as Processors or sets of Processors in the Camel. Processors are used for manipulation of messages between destinations specified in the Camel route.\cite{camel-dzone}



\subsection*{Domain-specific language}
There are few other integration frameworks with DSL and also some have support for describing route rules in XML. But bonus that comes with using Camel is its the support for specifying DSLs in regular programming languages as Java, Groovy, Ruby and even Scala. Of course there is also a possibility to describe the route in a XML document. 

\begin{listing}[ht]
	\inputminted[]{java}{sources/java_dsl_example.java}
	\caption{Java DSL definition of route}

\end{listing}

\begin{listing}[ht]
	\inputminted[]{xml}{sources/xml_example.xml}
	\caption{XML definition of route }

\end{listing}

\begin{listing}[ht, p!]
	\inputminted[]{java}{sources/scala_example.java}
	\caption{Scala definition of route }

\end{listing}


\subsection*{Modular and pluggable architecture}
The next feature is the approach to the architecture, which is done in modular way. This means that Camel can be easily extended to consume data from a endpoint and produce data to some other endpoint. Camel is describing this as developing a new component, where each component is responsible for consuming or producing data for some specific endpoint and technology e.g. \texttt{file}, \texttt{HTTP} and many others. When developers want to develop a new component for some unique system and add its functionality to the Camel, they just need to follow structure specified by the framework and extend core classes. 

By default Camel ships with the few most basic components called \textit{camel-core}. This bundle includes 24 components including components like \texttt{bean}, \texttt{file}, \texttt{log}, \texttt{seda} and \texttt{mock}. Plus there are many more components developed by the Apache community and also third-parties\footnote{\url{http://camel.apache.org/components.html}}. There are already developed components that can be used for the most common integration scenarios that occur in systems. Some components worthy of note are web services including SOAP\footnote{SOAP -- Simple Object Access Protocol}, REST\footnote{REST -- Representational State Transfer}, JMS\footnote{JMS -- Java Message Service}, specialized JMS component for Apache ActiveMQ\footnote{\url{http://camel.apache.org/activemq.html}} or components for different database connections.


\subsection*{Configuration}
As mentioned before Camel uses convention over configuration paradigm to minimize configuration requirements so developers don't need to learn complicated configuration options and can focus on more important things. This is reflected on configuration of endpoints in route definitions with URI\footnote{URI -- Uniform Resource Identifier} options as can be seen on example \ref{uri-option}.
\begin{listing}[ht]
	\inputminted[]{java}{sources/uri.java}
	\caption{URI options configurations}
	\label{uri-option}
\end{listing}

\subsection*{Type converters}
Next feature of Camel, which is one of the top features for Camel Community, are build-in automatic converters. Out of the box Camel ships with more than hundred and fifty converters\cite{camel-in-action}. Plus if there is no converter for your type, there is possibility to create new custom converters for your specific types. Usage of the converter can be seen on example \ref{converter}. The example also demonstrates use of the converter by Camel without user's knowledge in \textit{getBody()} method and its parameter.

\begin{listing}[ht, p!]
	\inputminted[]{java}{sources/converter.java}
	\caption{TypeConverter invocation}
	\label{converter}
\end{listing}


\subsection*{Lightweight framework}
From the start the whole framework was designed to be undemanding and lightweight as possible. The core library has only about 1.6 MB and third parties dependencies are kept at minimum. This way Camel can be easily embedded into any platform which can be e.g. OSGi\footnote{\url{http://www.osgi.org/Main/HomePage}} bundle, Spring application, Java EE application or web application. 

\subsection{Message model}
Until now we talk about sending data from one endpoint to another. That is exactly what is Camel doing but in reality it is sending and receiving messages which encapsulate the data. There two abstraction classes that are use for modelling messages in Camel and these are:
\begin{itemize}
\item
\texttt{org.apache.camel.Message} -- the basic entity containing data that is routed in the Camel 

\item
\texttt{org.apache.camel.Exchange} -- special abstraction used in Camel for exchange of messages, that has \textit{in} message and \textit{out} message as a reply

\end{itemize} 

\subsection*{Message}
The \texttt{Message} object is representing data that are used by systems to communicate with each other. \texttt{Messages} are sent in one direction from a sender to a receiver. The \texttt{Message} object consists of body, headers and optional attachments. All messages must be uniquely identified with an unique identifier(UID). The format of UID is not guaranteed and it is dependent on the used protocol. If the protocol doesn't have UID scheme, then generic generator from the framework is used.

Headers are name-value pairs associated with the \texttt{Message}, similar to HTTP protocol. They provide additional information about the \texttt{Message} such as sender identifiers, encoding, content type or authentication parameters. They are stored in a map within the \texttt{Message} and each name of the header is unique case-insensitive string and the value can be any Java object.

Body is representing content of the \texttt{Message} and its type is generic Java Object, so \texttt{Message} can store any kind or type of content. The sender should send body type acceptable by the receiver. If this is not the case then manual transformation inside the route is needed or more conveniently type converters are automatically used by the Camel.


\subsection*{Exchange}
An \texttt{Exchange} is defined as message's container encapsulating the \texttt{Message} used during routing. There are various types of interactions between systems and they are supported by the \texttt{Exchange}. These interactions are called message exchange patterns (MEPs) and they are used to specify messaging styles in the property of the  \texttt{Exchange}. This property has to two different messaging styles from which one is one-way and the other one is request-response. 

The request-response pattern or \textit{InOut} pattern called in the Camel, is probably the more well-known style, because it is used in HTTP-based transport, where client requests to retrieve a web resource and it is waiting for the reply from the server. One-way pattern is defined as \textit{InOnly} and for example is primarily use in JMS, where message is sent to the queue and sender doesn't need any response from the queue. These two types are just the basic ones, but Camel provides few more special cases\footnote{http://tinyurl.com/exchangePattern}.\cite{camel-exchange}
%http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/ExchangePattern.html

The \texttt{Exchange} is little bit more complex than the \texttt{Message} object and it is consisting from\cite{camel-in-action}:
\begin{itemize}
\item
Exchange ID -- is unique ID that identifies the exchange and it is also automatically generated by the Camel if ID is not explicitly set.

\item
Message exchange pattern (MEP) -- defines type of messaging style.

\item
Exception -- If an error occurred during routing, then exception is set into this field.

\item
Properties -- various properties of the \texttt{Exchange} used by Camel, similar to headers in \texttt{Message}. With difference that the properties last for the duration of entire exchange and contain global information, whereas message header are specific to the \texttt{Message}. They can be also edited by developers.

\item
In message -- mandatory input message containing request message.

\item
Out message -- optional message containing reply message if the MEP is set to \textit{InOut}.
\end{itemize}


\subsection{Camel's architecture}
This chapter will describe architecture of the Camel from high-level and then takes closer look on some specific concepts. The basic architecture of the Camel is shown in the figure \ref{camelContext} and should help with getting better picture of the runtime of \textit{CamelContext}.

\begin{figure}[!h]
\centering
\includegraphics[width=0.9\linewidth]{sources/CamelContextCrop.jpg}
\caption{Overview of CamelContext}
\label{camelContext}
\end{figure}

\subsection*{Camel context}
From the figure \ref{camelContext} it is clear that \textit{CamelContext} is somewhat similar to container but more precisely it is Camel's runtime system. This system keeps everything together and provides services during the runtime that are:
\begin{itemize}
\item
Routes -- routes that have been added to the context

\item
Endpoints --endpoints that have been created in context

\item
Components -- components used by the application and they can be added on the fly

\item
Type converters -- loaded type converters by the context

\item
Data formats -- data formats loaded into to the context

\item
Languages -- Camel supports different languages used in the expressions and these are loaded into the context

\item
Registry -- registry is used for the look up of beans. JNDI\footnote{JNDI -- Java Naming and Directory Interface} registry is used by default, but if Camel is deployed into Spring or OSGi container then it uses native registry mechanism specific to these technologies.

\end{itemize}

\subsection*{Routing engine and routes}
The routing engine is the thing that actually moves messages, but is not visible to users. It guarantees correct routing from the sender to the receiver.

The routing engine is using routes for its routing. Routes are the essence of the Camel and are the main and only approach how to specify what should be moved where for the routing engine. This means that the route must hold definition of input source to output target. There many possibilities for definition of the route, but the simplest way is to define route as a chain of processors\cite{camel-in-action}. Similar to \texttt{Message} or \texttt{Exchange}, each route has unique identifier that is used for different operations inside of Camel like monitoring, starting or stopping the route. One of the constraints for the route is restriction for the number of input sources, where each route must have exactly one input source that is tied to input endpoint and there can be one or several output targets.

\subsection*{Processor}
As mentioned before the simplest route consists from the chain of processors. The processor represents a node responsible for using, creating or modifying content of incoming \texttt{Exchange} and also its headers. In the chain of processors, exchanges moves during routing from one processor to a another in the their order defined in the route. This way a route can be seen as graph with nodes where output from the one node is input of another.

As stated previously, almost all built-in processors or their combinations are implementation of EIPs, but Camel also supports implementation of own custom processors and their easy addition to the route.

\subsection*{Component}
Components help with modular approach and they are main extension point in Camel. Their main purpose and task is to be a factory of endpoints. As mentioned before developers can create their new components, more information and detail on this topic will be given in subchapter \ref{component-devel}. 

\subsection*{Endpoint}
An endpoint is a abstraction in the Camel that models the end of message channel. In other words it represents sender or receiver. Endpoints are configured and referred in route using URIs and Camel also looks up a endpoint during runtime by its defined URI. Format of the URI is show on figure \ref{uri} and it is consisting from three parts: \textit{scheme}, \textit{context path} and \textit{options}. 

The \textit{scheme} specifies which component should be used. In the figure \ref{uri} is used scheme texttt{file} that represents Camel \texttt{FileComponent} that creates \texttt{FileEndpoint}. The component developed in this thesis uses scheme called \textit{resteasy}. The \textit{context path} describes the location of specific resource for the endpoint, similar to a web page on the server. The last part of the URI is \textit{options} that is used for specific configuration of the endpoint.

The last task of endpoint is to be factory for creating producers (sender) and consumers (receiver) that are capable of receiving and sending messages in routes.

\begin{figure}
\centering
\includegraphics[width=0.9\linewidth]{sources/Diagram1.jpeg}
\caption{Overview of endpoint URI}
\label{uri}
\end{figure}

\subsection*{Producer}
A producer is a entity capable of creating and sending a message to an endpoint. Its main task is creating a \texttt{Exchange} and populating it with content compatible with the endpoint specification. For example, \texttt{JmsProducer} will map Camel message to JMS message before sending it to JMS destination. The producer developed in this thesis acts as HTTP client sending HTTP requests using client API from RESTEasy.


\subsection*{Consumer} 
As stated before, every route has just one starting point and that is the consumer. The consumer is something like receiver of messages, where the message is sent. Its task is to wrap the message into \texttt{Exchange} and add headers. Exchanges created by consumer are then send and routed in defined chain of processors.

Camel defines two types of consumers: event-driven and polling consumers. The event-driven consumer is probably more famous and known because it is associated with client-server architecture and its communication. In EIPs is this consumer referred also as \textit{asynchronous} receiver and its job is to listen on messaging channel, waiting for the incoming messages.

A polling consumer is working little bit different than event-driven consumer. It is active consumer that goes to defined address in endpoint and fetches messages from it. Similar to event-driven consumer, polling consumer has different name in EIP world and it is commonly called \textit{synchronous} receiver. This means that all received messages have to be processed before the consumer polls for another one. Common usage of polling consumer in Camel is scheduled polling consumer that checks and polls messages in defined time interval.


 
\section{Development of the new component}\label{component-devel}
As already stated, developers can exploit Camel modular architecture and easily extend Camel and add new protocols without necessity to change core of the framework. This feature is achieved by Camel components and by developing new custom component for new protocol. This section describes some of the fundamental principles associated with creation of the custom component.

Camel is built using Apache Maven\footnote{\url{https://maven.apache.org/}} so the easiest and fastest way to create a custom component from a scratch is to use Maven archetype\footnote{\url{https://maven.apache.org/guides/introduction/introduction-to-archetypes.html}}. Camel offers several archetypes\footnote{\url{http://camel.apache.org/camel-maven-archetypes.html}} for different tasks and projects. Archetype \textit{camel-archetype-component} is used for creating a maven project, that is a base for developing a new custom component\cite{camel-comp}. 

The created project is fully functional \textit{HelloWorld} demo component containing consumer that generates messages and producer for printing them to the console. Modifying this example is great for creating a custom component. The first thing to do is to decide what name will be use in endpoints for referencing the component. This name must be unique so it doesn't create conflict with other components. List of the existing Camel components can be found on official web pages\footnote{\url{http://camel.apache.org/components.html}}

\subsection{Hierarchy of classes}
Camel component consists from four main classes that together create component and that are \texttt{Component}, \texttt{Endpoint}, \texttt{Producer} and \texttt{Consumer}. Of course component can have many more classes used in the component for its correct functionality, but only these four are important for creation of correct component in Camel. As stated before, their relationship is that everything starts with \texttt{Component} class, which creates an \texttt{Endpoint}. An \texttt{Endpoint} then creates \texttt{Producers} and \texttt{Consumers}.

Once again Camel offers some default classes for each of these classes, that can be extended for easier development and not everything needs to be created from the scratch.

\subsection*{Component class}
Main job of this class is to be a factory of endpoints. This class needs to implement \texttt{Component} interface and primarily implement its \texttt{createEndpoint()} method. The easiest way to achieve this is to extend \texttt{DefaultComponent} class. Of course there is also possibility to extend other component classes from other components and leverage theirs functionality.

\subsection*{Endpoint class}
Main task of endpoints is to be factory for \textit{Consumers} and \textit{Producers}. The \texttt{Endpoint} class needs to implement \texttt{Endpoint} interface that has creation methods for both of them. The simplest way is to extend \texttt{DefaultEndpoint}. Also not all components have to have both \textit{Producer} and \textit{Consumer}. It is common that in some components one of them is not needed or doesn't make sense in regards to used technology. This class can also contain all parameters that can be set as URI options on the endpoint. Parameters are usually annotated with \texttt{@UriParams} annotation and set though reflection by Camel.

\subsection*{Consumer and Producer class}
As already stated, the \textit{Consumer} is starting point though which messages enter the route. Camel of course offers some default implementation for event-driven and polling consumers. This class has no major restrictions how should be implemented, it just needs to implement \texttt{Consumer} interface with its method \texttt{getEndpoint()}. In the component developed in this thesis, \texttt{ResteasyConsumer} connects to running web servlet and it is consuming requests and responses from the RESTEasy web service. 

The \textit{Producer} is responsible for sending messages outside. Similar to \texttt{Consumer} class there are no given restrictions on the implementation, it just needs to implement \texttt{Producer} interface, which extends from the \texttt{Processor} interface that has only one method \texttt{process()}. But it is recommended to extend \texttt{DefaultProducer} class to keep it simple. \texttt{ResteasyProducer} acts as HTTP client that sends HTTP requests to specified target.


\section{REST}
For most of people in modern world, World Wide Web is almost fundamental part of their life and they take it for granted. It is a given fact that Web has been very successful and it has grown from simple network for researchers and academics to interconnected worldwide community. 

Roy Fielding tried to understand this phenomenon and find out what was the reason or factor for this incredible change in his PhD thesis, Architectural Styles and the Design of Network-based Software Architectures\cite{rest-arch}. In it, he asks three important questions connected with the Web:
\begin{itemize}
\item
Why is the Web so prevalent and ubiquitous?

\item 
What makes the Web scale?

\item
How can I apply the architecture of the Web to my own applications?
\end{itemize}

From answers to these questions, he identifies five specific architecture principles called Representation State Transfer (REST) and these principles are:

\begin{itemize}
\item
Addressable resources -- resource in REST is abstraction of information and data and it must be addressable via URI.

\item
A uniform, constrained interface -- applications should use only a small set of well-defined methods that can manipulate resources.

\item
Representation-oriented -- a resource referenced by one URI can have many different formats, similar to different platforms that need different formats, e.g. HTML\footnote{HTML -- HyperText Markup Language} for web browsers or JavaScript clients needs JSON\footnote{JSON -- JavaScript Object Notation}. The REST application should interact with a service using representations of that service. 

\item
Communicate statelessly -- stateless applications can be scale more easily.

\item
HATEOAS\footnote{HATEOS -- Hypermedia as The Engine of Application State} -- data formats should drive state transitions in the application

\end{itemize}

These principles are the reasons, why Web became so successful, enormous and pervasive.\cite{resteasy-book}

\subsection{REST over HTTP}
The REST architecture isn't protocol-specific, but it is usually associated with HTTP protocol. The HTTP protocol is primarily used in browser-based web applications, but these applications don't fully leverage all features from it. There are also others web technologies like SOAP that uses HTTP protocol only for transmission and uses only small fraction of its capabilities. Because of this, it may seems like HTTP protocol is not very useful and it has only small set of features. 

In reality, HTTP is very rich and powerful synchronous request/response-based application network protocol with many useful and interesting capabilities for developers. It is used for distributed, collaborative, document-based systems. The protocol works in simple way, the client sends request message with defined HTTP method to be invoked, headers, location of resource for invocation and it can also contain message body that can almost anything.

The server that handles the request message, will send response message with response code, message explaining the code, headers and optional message body. HTTP defines several response codes for different scenarios\footnote{\url{http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html}}.\cite{resteasy-book}

\subsection{RESTful webservices}
As stated previously, REST was really just explanation for Web's success and growth, but after few years after the publication of Fielding's PhD thesis, developers realized real potential of REST. They realized that concepts described in the REST architecture can be used for building distributed services and modelling SOAs\footnote{SOA --Service-Oriented Architectures}. 

SOA is a design pattern that is used for a long time. The simplest description of main concept and idea of SOA is that systems should be designed as set of small reusable, decoupled and distributed services. By combining these services and publishing them on the network, should create larger and more complex systems. There were several technologies used for building SOAs in the past like CORBA or Java RMI. Nowadays, most associated technology with SOA are SOAP-based web services.  


\subsection{RESTful architectural principles}
A web service build upon principles of REST architecture are called RESTful web services. These services are used for building systems based on SOA principles. This section will describe each of the architectural principles of REST in more detail and explain why these principles are important for writing a web service.


\subsection*{Addressability}
An addressability in the systems means that every resource is reachable by the unique identifier. For this, standardized object identity in environment is needed which is not so common in environments. In RESTful services, addressability is achieved by use of URIs and each HTTP request must contain URI of the object that is requested. The format of URI must be of course standardized and it shown on example \ref{rest-uri}.

\begin{listing}[ht]
	\inputminted[]{bash}{sources/rest-uri.java}
	\caption{URI format}
	\label{rest-uri}
\end{listing}

The format of URI is break down to six parts, where first part is \textit{scheme} that specifies protocol used for the communication, in RESTful web service it is usually \textit{http} or \textit{https}. Next ones are \textit{host} that contains DNS\footnote{DNS -- Domain Name System} name or IP address and optional \textit{port}. These two parts represent a location of resource on the network. After them is \textit{path} part that specifies path to desired resource, similar to directory list of a file on the file system. Last two parts are optional where \textit{query} is list of parameters represented as name-value pairs delimited by "\&" character and \textit{fragment} part is usually used to point to a certain place in the queried document.

\subsection*{A uniform, constrained interface}
To fulfil this principle of REST, application must only use finite set of operations of the application protocol on which are its services distributed. When developing RESTful web service, this means only use methods of HTTP protocol. There are only few operational methods defined on HTTP where each method has specific purpose and these methods are:

\begin{itemize}
\item
\textit{GET} -- an read-only operation used for querying server for specific information. This operation is idempotent, which means that applying this operation over and over will always generate the same result. It also safe in meaning that it doesn't change the state of the server.

\item
\textit{PUT} -- an operation used for storing message body on the server, usually modelled as insert or update. It is also idempotent, because sending the same message more than once has no effect on the server.

\item
\textit{DELETE} -- the name is self-explanatory, an idempotent operation for removing resources.

\item
\textit{POST} -- an operation for modifying (updating) the service. It is only nonidempotent and unsafe operation of HTTP. This means that the request may or may not contain information and also response may or may not contain information.

\item
\textit{HEAD} -- similar to \textit{GET} except no body is returned, only headers and response code.

\item
\textit{OPTIONS} -- an operation for getting information about communication options. Mainly used for getting information on capabilities of the server and a resource without triggering any actions.

\item
\textit{TRACE} and \textit{CONNECT} -- unimportant operations without any use in RESTful web service.
\end{itemize}

Plus constraining interface of web service has few more advantages. One them is interoperability. HTTP is ubiquitous protocol and almost all modern programming languages have HTTP client library. So, it makes sense to expose web service over HTTP, because people will be able to use the exposed web service without any additional requirements. Older technologies have vendor specific client libraries and generated stub codes like \textit{WSDL} files, that creates problem with vendor interoperability in applications. RESTful web services don't have these problems and developers can focus on more important things in the application.

A constrained interface with its well-defined methods have predictable behaviour that can be leverage for better performance. This means RESTful web services are better in scaling, which is another advantage and that is scalability. RESTful web services are taking the advantage of the caching mechanism of the HTTP protocol. HTTP has very rich configuration for caching semantics that can be used for better performance. So, it is possible to configure caching semantics on defined method and make the same calls on same clients load much faster, because most of the information were cached on the first call. This is use of the same principle as with web pages and browsers. 

\subsection*{Representation-oriented}
The complexity of interaction between client and server in RESTful application is in representations being passed back and forth. Representations can be for almost in any format used in systems, for example XML, JSON, stream, YAML\footnote{YAML -- YAML Ain't Markup Language}. Because RESTful web services are communicating via HTTP, message bodies of requests and responses are acting as representations.

HTTP provides \texttt{Content-Type} header for specification of data formats use between client and server. Value of this header is string in MIME\footnote{MIME -- Multipurpose Internet Mail Extension} format, which is very simple: \textit{type/subtype;name=value;}. Where \textit{type} is the main format family and \textit{subtype} is a category. Plus there is a possibility to define name/value properties. Some of the common examples are:

\begin{itemize}
\item
\textit{text/plain}

\item
\textit{application/xml}

\item
\textit{text/html;charset=iso-8859-1}
\end{itemize}

Another feature of HTTP is a possibility for an negotiation of message formats sent between the client and the server, which very useful in web services. There is also a possibility to define a \textit{Accept} header on the client that describes preferred formats of responses. This can be used for the definition of services on the same URIs and same methods but with different return MIME type. Using this, an application can have similar methods but each for a different client with its preferred data format.

\subsection*{Stateless communication and HATEOAS}
Next mentioned principle of RESTful web service is its statelessness, but this means that the application cannot have a state. Stateless in RESTful means that server doesn't store any client session data and instead only manages states of resources it exposes. Session specific data, if they are needed, must be maintained by the client and can be send with the request if needed. This feature can be leverage for easier scaling in clustered environments because only machines need to be added for a scale up. 

The last principle of RESTful web services is HATEOS where the main idea is using Hypermedia As The Engine of Application State (HATEOAS). This approach is very useful because hypermedia have added support for embedding links to other services or information within the document format. One of the uses is for example, aggregating complex sets of information from different sources and using hyperlinks in the document to reference additional information without bloating responses. But the "engine" part is much more useful because it is different approach from traditional and older distributed applications that have a list of services they know exist. These applications then call central server for a location of these services. Instead RESTful web services with each response returned from a server define new possible interactions that can be done next, as well transition state of the application.

\section{RESTEasy}
RESTEasy is a JBoss project providing frameworks for building RESTful Web Services and RESTful Java applications. This means that it is a fully certified and portable implementation of the JAX-RS specification which can run in any servlet container. It is also no surprise that it is fully integrated with JBoss Application Server and WildFly to make better experience in that environment. To understand better what exactly is RESTEasy, it is required to understand what exactly is JAX-RS specification.\cite{resteasy-doc}

 
\subsection{JAX-RS 1.0 and 1.1}
RESTful services could be developed in Java for a long time using servlet API, but this approach is really hard and requires lot of code for simple operations. To simplify implementation of RESTful service, a new specification was defined in 2008 called JAX-RS. JAX-RS is a new JCP specification that provides a Java API for RESTful Web Services over the HTTP protocol. This section will just provide some basic information about the this specification. The more detailed description and documentation can be found on official web page of JAX-RS\footnote{\url{https://jax-rs-spec.java.net/}} or on RESTEasy web page\footnote{\url{http://resteasy.jboss.org/}}. 

JAX-RS is a framework that focuses on applying Java annotations introduced in Java SE 5 on plain Java objects. JAX-RS API is part of JSR-311\footnote{\url{https://jcp.org/en/jsr/detail?id=311}}. To simplify development of RESTful Web Services, this framework has annotations to bind specific URI patterns and HTTP methods to individual methods in the basic Java class. It has also parameter injection annotations for easier parsing of information from HTTP requests. Another feature are message body readers and writers for decoupling data format marshalling and unmarshalling from custom Java objects. Also it has exception mappers for mapping application-thrown exceptions to HTTP response code and message. The last useful feature that it provides are facilities for HTTP content negotiation.\cite{resteasy-book}\cite{jax-wiki}

JAX-RS 1.1 is upgrade version of the same framework with few changes. The biggest one is that is became official part of Java EE 6, which means that no configuration is necessary to start using JAX-RS. Some of the enhancements to the framework include adding examples to clarifying and correcting Javadoc comments related to use of JAX-RS. There was also added new annotation \texttt{@ApplicationPath}, which can be use to specify base URI for all \texttt{@Path} annotations. Complete list of all changes can be found in the official changelog\footnote{\url{https://jcp.org/aboutJava/communityprocess/maintenance/jsr311/311changelog.1.1.html}}. \cite{jax-1.1}\cite{jax-1.1-2}

It is important to note that both JAX-RS 1.0 and 1.1 are only server-side specifications without any support for the client side. But this drawback was removed in the version 2.0 and will be described in a more detail in the next subsection.

\subsection{JAX-RS 2.0}\label{jax2.0}
With Java EE 7 release also came new version of JAX-RS 2.0 that upgraded the framework and added new features from which the key features are:
\begin{itemize}
\item
Client API

\item 
Server-side asynchronous HTTP

\item
Filters and interceptors
\end{itemize}

This subsection provides basic overview of mentioned features. Of course there are other minor features and upgrades to make the framework more useful and stable.

\subsection*{Client API}\label{client-api}
Both previous versions of JAX-RS specification were missing client API, as it was stated previously. Because of this missing feature, each implementation of JAX-RS created their own client API, which is not so great for standardized framework. So version 2.0 contains fluent, low-level, request building API that can be seen on example \ref{rest-client}. 

\begin{listing}[ht]
	\inputminted[]{java}{sources/client.java}
	\caption{Client API}
	\label{rest-client}
\end{listing}

The base of the API is \texttt{Client} interface that manages HTTP connections and acts also as a factory for \texttt{WebTargets}. \texttt{WebTarget} represents specific URI for a request and the whole request is build and executed on it. In most times the return object is \texttt{Response} from which \texttt{readEntity()} method is used for getting the entity. API also provides way to get specific Java object directly without working with \texttt{Response} object as shown on example \ref{rest-client} with \texttt{Car} object.

Client API also provides support for asynchronous requests which can be use for the execution of HTTP requests in the background. There are two possibilities to get the response and that is either polling or receiving a callback. For polling is used \texttt{Future} interface which is part of JDK from version 5.0 and client example with \texttt{Future} is shown on example \ref{future} in the appendix. For callbacks is used \texttt{InvocationCallback} interface shown on example \ref{callback}, where the request is registered with the callback instance and is invoked in the background. The interface depending on the status of the response executes a defined code\cite{jax-rs-2.0-new}\cite{jax-rs-2.0}. The client example with callback is shown on example \ref{callbackClient}.

This subsection just gave a quick look on the Client API. For more detail about the Client API check the specification and the Javadoc of JAX-RS 2.0.

\begin{listing}[ht]
	\inputminted[]{java}{sources/callback.java}
	\caption{InvocationCallback interface}
	\label{callback}
\end{listing}

\subsection*{Asynchronous server-side}
Typical HTTP server works in a way that when requests comes in, one thread is responsible for processing and generating response to the client. This is no problem because requests are short-lived, so few hundred threads can handle few thousand concurrent users with good response times. This was fine until evolution of services and HTTP traffic with JavaScript clients. One scenario started to became a problem and that is the scenario where the server needs to push events to the client. In this scenario, clients need to know actual information from the server, for example a stock price, so they usually send \textit{GET} request and just block indefinitely until the server is ready to send back a response. With many clients, this creates large amount of open, long-running requests that are just idling and also threads with them. This scenario is very consuming on operating systems resources and it is really hard to scale up these server-push applications, because JAX-RS had one thread per connection model.\cite{resteasy-book}

To conquer this problem, JAX-RS 2.0 provides a new feature and that is a support for asynchronous HTTP. With it, it is possible to suspend the current server-side request and have different thread handle sending back the response to the client. This feature can be used to implement long-polling interfaces or the server-side push as mentioned. The server-side push problem can be resolved with small set of threads delegated just for sending  responses back to polling clients.

This feature is very analogous to Servlet 3.0 specification and similar to other features of JAX-RS, it is also annotation driven. To use this feature, the application must interact with \texttt{AsyncResponse} interface. This is done by injecting this interface into JAX-RS method with \texttt{@Suspend} annotation.\cite{resteasy-book}\cite{jax-rs-2.0} Example is provided in appendix \ref{async-server} and more detail information can be found in the specification and the Javadoc of JAX-RS 2.0.

\subsection*{Filters and entity interceptors}
Last notable new feature of JAX-RS 2.0 are filters and entity interceptors. They are used for intercepting requests and the response processing. Notable use cases are authentication, caching or encoding. Similar to the Client API, most implementations of JAX-RS implemented their own interceptors prior to version 2.0. The framework defines two concepts for interceptions and they are:
\begin{itemize}
\item 
filters

\item
entity interceptors
\end{itemize}

Filters are used for a modification or processing of incoming and outgoing requests or responses. They are executed before and after the request and the response processing. Main task for entity interceptors is marshalling and unmarshalling of message bodies.

In filters, there are two main groups: server-side filters and client-side filters. Both groups have two different filters for the request and  the response. Server-side filters are \texttt{ContainerRequestFilter} that runs before JAX-RS resource method is invoked and \texttt{ContainerResponseFilter} that runs after the invocation of the resource method. A added feature for \texttt{ContainerRequestFilter} is a possibility to specify when the filter should be invoked, before the resource method is matched or after it is matched. This is defined by \texttt{@PreMatching} and \texttt{@PostMatching} annotations. Client-side filters have also two types: \texttt{ClientRequestFilter} and \texttt{ClientResponseFilter} where request filters run before sending the HTTP request to the server and response filters run after receiving response from the server, but before the response body is unmarshalled. \cite{jax-rs-2.0}\cite{resteasy-book}

Interceptors deal with message bodies and are executed in the same call stack as their corresponding reader and writer. Again there are two different types. One type is \texttt{ReaderInterceptor} that wraps around \texttt{MessageBodyReaders} and the second type is \texttt{WriterInterceptor} that wraps around \texttt{MessageBodyWriters}. They are many uses for these interceptors like a implementation of specific encoding, generating digital signatures or posting and preprocessing a Java object before or after it is marshalled.\cite{jax-rs-2.0}


%\subsection{Features of RESTEasy}\label{resteasy}


\section{Existing RESTful components}
The official distribution of Camel already provides several components that are used for a integration with RESTful Web Services. There are mainly similar project to RESTEasy, that are also certified implementations of JAX-RS 2.0 specification. Notable examples are:
\begin{itemize}
\item
Camel CXF

\item
Camel Restlet

\item
Camel Spark-rest

\item
Camel Rest
\end{itemize}

Each component and technology has specific pros and cons. Spark-rest is component integrating Spark Rest Java library running only on Java 8 and supporting only consumer endpoint. Spark-rest is not a certified implementation of JAX-RS 2.0, but can be for the server-side. Restlet and CXF components are integrating Restlet and CXF frameworks, both have producer and consumer endpoints along with few unique features. 

The last component is Camel Rest that was added in Camel 2.14. It is used for defining REST endpoints using REST DSL\footnote{\url{http://camel.apache.org/rest-dsl.html}} right in the Camel route. There is also a possibility to configure this component to use some other RESTful component as a base. Any component can be integrated with REST DSL if they have a Rest consumer in Camel. For the integration, new component must implement \texttt{RestConsumerFactory} and the component itself then must implement logic to create a Camel consumer that exposes the REST services based on the given parameters, such as path, verb, and other options.

\subsection{Camel Resteasy -- motivation}
As for now Camel already provides RESTful components, so why exactly do we need a new RESTful component if there are components capable to satisfy user's needs. Best answer is probably, because we can. If there are more implementations of the JAX-RS specification, then there should be Camel component for the each one. This way, users are not limited and can choose component for their preferred implementation. 

Another thing to consider is the tight connection between RESTEasy and products like JBoss EAP, JBoss AS or WildFly. All these servers have RESTEasy integrated and are using out for box. Adding a possibility to also create Camel routes integrated with RESTEasy on these servers can help lot of users which are already familiar with RESTEasy framework. Of course they is no problem to deploy application with CXF implementation and user Camel CXF component on these servers, but that just complicates things if we can just easily create a RESTEasy component. 

%
\chapter{Analysis and Design}
This chapter describes software analysis of new Camel component, and it is taking into the account facts written in previous chapter. Given that the development of new Camel component is pretty restricted and it must follow base skeleton given by the framework, not every part of software analysis is needed. The most useful part of software analysis in this scenario are data flow diagrams (DFD). But the first thing to do, is to identify base requirements for the new component, so the analysis starts with identifying these requirements. Next section then shows data flow diagram (DFD) that illustrate message flow in Camel. This should also help to understand how will the new component work. Last part of this chapter is description of design decisions made on facts provided in this chapter. 

\section{Requirements}
The purpose of the thesis is to integrate RESTEasy project with Apache Camel framework as it is defined in assignment. That means creation of new Camel component that will be exposing REST interface endpoints in Camel, so basically a consumer. Because it should be integrated with RESTEasy project, the exposed endpoints should be configured via JAX-RS annotations provided by RESTEasy. As mentioned previously, the newest version of RESTEasy is also fully certified implementation of JAX-RS 2.0 specification which means it also provides client API that should be use as Camel producer. This component is required by community for some time and the requirement is logged in  
the Apache's Jira\footnote{\url{https://issues.apache.org/jira/browse/CAMEL-2983}}.

The assignment is only basic description of Camel component so there any really detailed listing of requirements and special features for this component. Therefore more detailed list of requirements and in some cases even restrictions was composed after analysis of RESTEasy project. Also some inspiration came after analysis of similar components providing REST endpoints. This is quick overview of defined requirements and default features for both consumer and producer.

\subsection{Consumer}
\begin{itemize}
\item
ability to create consumer connected with defined REST web service by RESTEasy (basic consumer)

\item
ability to create consumer defined in the route (camel proxy consumer)

\item
ability to define REST web service as interface with RESTEasy annotations with Consumer in the route and creating Response via route (proxy consumer)

\item
define allowed request methods for consumer defined only in the route


\item
ability to change Response returned from REST web service in the route, before it is send to the client 

\item
both request and response should be routed into the route

\item
DSL and Spring support


\end{itemize}

\subsection{Producer}
\begin{itemize}
\item
send HTTP request to defined target using RESTEasy Client API

\item
provide possibility for basic authentication with URI options

\item
ability to use RESTEasy Proxy Framework Client API (more detail will be given in chapter \ref{})

\item
DSL and Spring support
\end{itemize}

\section{Camel's data flow}
This section contains two DFDs illustrating data flow incoming into Consumer and outgoing from Producer. 

As defined in previous section, the new component provides three types of Consumer. Each of them has little bit different data flow, so to better understand them, there are three diagrams. The first diagram shown on the figure \ref{}, shows basic Consumer data (message) flow, where RESTEasy process HTTP request and create response according to implementation of service without sending it to the client. Afterwards, the response is send to Camel route as Exchange for another processing. HTTP request is also bundled into the Exchange in a special header. When the processing  is done, the final Response is returned to the client. 

The second diagram shown on the figure \ref{}, depicts data flow of the second type of consumer. This is a consumer, which is internally called Camel Proxy Consumer in this thesis. This type of Consumer is defined only in the route, that is exposing it as web service. The request should be processed in the route along with creation of response for the client. This consumer is really only bonus feature, that can be used for creation really simple web service without need to create class with JAX-RS annotations. 

Next diagram shown on figure \ref{}, illustrates the last possible Consumer in the new component, which is internally called Proxy Consumer. In this type of Consumer, users only have to define interface with desired methods annotated with JAX-RS annotations. In this type, RESTEasy will take care of processing and matching HTTP request, which is afterwards send for processing as Exchange into the route and response should be created in the route.  


The final diagram shown on figure \ref{}, depicts message flow in a Producer. Producer message flow is reverse to Consumer message flow. It process Exchange from the route and send the HTTP request to the target. 


\chapter{Implementation}\label{impl}
As stated before, the goal of this thesis is to integrate Apache Camel and RESTEasy to create a new Camel Resteasy component. This chapter describes source code and implementation of Camel Resteasy component. 

The implementation was done in Java programming language, similar to Camel core and other components. It was also implemented with regards to restrictions set by Camel framework for components mentioned in previous chapters. Version that were use in the source code:
\begin{itemize}
\item
Java 1.7

\item
Apache Camel 2.14.0

\item
RESTEasy 3.10.0
\end{itemize}

\section{Class diagram}
The final fully exported class diagram for the Camel Resteasy component can be found in appendix \ref{}. Sections describing single classes of the component will use only single class diagrams.

\section{ResteasyComponent class}
ResteasyComponent class is the base of the whole implemented component and it is where everything starts. It extends HttpComponent to leverage already implemented code needed to run in Camel, after all Resteasy component is similar to HttpComponent, because it consumes HTTP requests. As it was already mentioned, main purpose of Component class is to be a factory of endpoints. Therefore createEndpoint() method must be implemented and it must override the same method from HttpComponent.

There is nothing special about implementation of this method. The first thing it does is that it reads all the configuration URI parameters and removes them to prevent mistakes in matching them as query parameters. Endpoint URI is then parsed from the rest of cleaned URI.

There are two more methods that override methods from HttpComponent. These methods are connect() and disconnect(). They are use for connecting and disconnecting consumers from HttpRegistry. More about this class in section \ref{}. 

This class also implements RestConsumerFactory interface to support configuration of route and options in REST DSL. To implement this interface, method createConsumer() must be implemented. This method just parse REST configuration from DSL and creates endpoint belonging to this configuration.

ResteasyComponent has also one special property that can be set, when creating component in the Camel context. The name of property is proxyConsumersClasses and it is a String property that can be set to fully qualified names of Java interfaces annotated by JAX-RS annotations separated by comma. More detail about this property and its usage will provided in section \ref{servlet}.

\section{ResteasyEndpoint class}
ResteasyEndpoint is straightforward class that use as factory for creating Consumers and Producers for Resteasy component. Therefore there are two methods for this purpose, createConsumer() and createProducer(). These methods are self explaining, so there is nothing to add. This class also extends HttpEndpoint, to leverage already implemented code that is use in Consumer part.

This class also holds all the configuration parameters that were parsed in ResteasyComponent. Parameters are annotated with @UriParam for easier setting using Java Reflection API. The full list of parameters and their basic description is given in next subsection.

\subsection{Parameters}
There is not lot of configuration parameters for this component, but few of them are unique, so the list of parameters also provides basic description. Also some parameters are specific only for Consumer or Producer, which will be noted also in the list. This list contains some options for which it could be hard to understand their meaning or purpose, just from short description. More detail about their meaning and usage will be provided in sections \ref{} and \ref{}, depending if they are consumer or producer options.  

List of URI parameters for Resteasy endpoint:
\begin{itemize}
\item
servletName -- specifies the servlet name that the endpoint will bind to. This name should match the name of the servlet, that maintains the REST services and it is defined in web.xml. This option is for consumer only and it is required option. 

\item
resteasyMethod -- use to define, which HTTP method should be used in HTTP client. This option is for producer only. This option can also be specified in CamelResteasyHttpMethod header, which also overrides URI option.

\item
restEasyHttpBinding

\item
proxyClientClass -- options that is used only in producer and it is used for definition of name of the proxy class used in client proxy call.

\item    
proxyMethod -- option required if proxyClientClass is specified, therefore only usable on producer endpoint. This option is used for definition of name of the method, that should be inovked in proxyClientClass.

\item
proxy -- boolean option that can be use on only consumer endpoint. If set to true, then camel with register this consumer as proxy. 

\item 
camelProxy -- if set to true, then this address is only specified in Camel. Can be used only on consumer endpoint.

\item
username -- username for basic authentication on producer endpoint.

\item
password -- password for basic authentication on producer endpoint.

\item
throwExceptionOnFailure -- ????
\end{itemize}


\section{Resteasy Consumer}
Consumer part is essential part of this component, because it is really the most useful part of integration between Camel and RESTEasy and it is also in this part where Camel Resteasy is different in some way compared to other components. The most important thing to note is that RESTEasy doesn't provide any other way how to create a RESTEasy server other than create web.xml file in the application. In this file must be specified servlet for RESTEasy, which provides it own servlet class named HttpServletDispatcher. In contrast, other implementation of JAX-RS specification like CXF or Restlet provide way to create their servers programmatically or as a bean in Spring or OSGi.

Therefore components base on these projects, usually create the server in their Consumer class and handle requests along with their integration with Camel. Something similar cannot be done with RESTEasy and that is why is ResteasyConsumer class is so simple as seen on figure \ref{}. Basically this class just acts as a proxy consumer class so Camel knows there exists a consumer for this component.

As a reminder, the component defines three types consumers:
\begin{itemize}
\item
Basic Consumer  -- fully implemented class with JAX-RS annotations and defined path in the consumer endpoint

\item
Proxy Consumer -- only interface with JAX-RS annotations, that must be specified in component property \textit{proxyConsumersClasses}. The consumer endpoint with this consumer has to have \textit{proxy} option set to true. 

\item
Camel Proxy Consumer -- just specified path on consumer endpoint with base URI provided by the servlet. The consumer endpoint with this consumer has to have \textit{camelProxy} option set to true. 
\end{itemize}




\subsection{ResteasyCamelServlet class}\label{servlet}
ResteasyCamelServlet is the real consumer in Resteasy component. It is extending HttpServletDispatcher class from RESTEasy and acting as a servlet. There are few methods and the most important is service(). This method is responsible for handling request, creating response, sending them both to Camel route and sending the final response back to the client. It also taking into the account all configuration options on URI, so it takes care of all three types of consumers in specific way. 

The Basic Consumer takes into the account there is fully implemented web service registered in the servlet runtime. So the request for this consumer is first handled by the servlet extended by the ResteasyCamelServlet and the response is returned. If the request was invalid, then the created response from service is returned. If the request was correct, then response is set as Exchange body and send for processing into the Camel route. When the processing is done then the final response is sent back to the client. 

The Proxy Consumer works in similar way. One difference is that if the request was correct then the status code 204 is returned. This code means there was no problem with the request but there is no content for response. That is a correct behaviour, because only annotated interface was provided. In this scenario the request body in set as Exchange body and it is send for processing into the Camel route. The response should be created in the Camel route, so it can be returned back to the client.

The last type of the consumer is Camel Proxy Consumer. This consumer skips the part of handling the request to extended servlet, otherwise it working exactly the same as the Proxy Consumer.     

Another important method is init(), which is use for creation of ResteasyCamelServlet and registering it HTTP registry. Description of HTTP registry and HttpRegistry class will be provided in section \ref{registry}. This method is also responsible for proxy consumer type. This special consumer was invented as bonus feature for the component, for scenarios where response to the request can be created in Camel route with data from some others systems integrated with Camel. This means that user doesn't need to implement full RESTful service but he just needs to create interface with JAX-RS annotations. This scenario can be very useful to some users, but there is a problem with RESTEasy, which  doesn't register just interfaces with annotations. RESTEasy registers interface with annotations only if there is also a class implementing this interface. This problem is solved in init() method with use of Java Reflection API\footnote{\url{http://docs.oracle.com/javase/tutorial/reflect/index.html}}. If user wants to use this feature, he must specify created interfaces in proxyConsumersClasses property on the ResteasyComponent. The init() method parses these interfaces and using the Reflection API creates dynamic proxy classes\footnote{\url{http://docs.oracle.com/javase/7/docs/technotes/guides/reflection/proxy.html}} for them. These dynamic proxy classes are then registered into the RESTEasy runtime as new resources.

There are few more methods in this class, but there are really straightforward. The resolve() method is used for resolving which consumer should handler the request. Methods connect() and disconnect() are use for connecting and disconnecting consumers. 

\subsection*{ResteasyFilter}
ResteasyFilter is class annotated with @Provider annotation and implementing Filter interface. The annotation takes care of registering the filter to the servlet without need to be specified it in web.xml. This filter doesn't do anything special, its main task is just wrapping requests and responses into custom wrappers created in the component. This must be done because bodies of requests and responses needs to be processed and read more than once in ResteasyCamelServlet to be fully integrated with Camel.

For this purpose, two wrappers ResteasyHttpServletRequestWrapper and ResteasyHttpServletResponseWrapper were created. Their main task is to create a copies of bodies of requests and responses, so  ResteasyCamelServlet can manipulate with them much more easily.


\subsection{HttpRegistry class}\label{registry}
HttpRegistry is sort of helping class for Consumer in this component. It primarily use in ResteasyCamelServlet and ResteasyComponent to connecting and disconnecting consumers. In short, HttpRegistry interface keeps track of running ResteasyServlets and ResteasyConsumers (HttpConsumers) belonging to them.  To be able to that, it provides methods for registering and unregistering servlets and consumers from the registry.

The Resteasy component also provide default implementation of this interfaces, DefaultHttpRegistry. This default implementation is used as a default in the component. There is also possibility to create own implementation of this interface and set it in ResteasyComponent for usage instead the default one. 


\section{ResteasyProducer class}
ResteasyProducer represents client part and is implemented using Client API provided by RESTEasy. It extends DefaultProducer and it is overriding process() method. There are also few methods there primarily used as a helping methods, for creating the right URI, adding query or getting producer configuration options specified URI in endpoint. Main task of producer is getting data from Exchange and send HTTP request to the specified target in endpoint and this is the task of process() method. 

RESTEasy implementation of Client API has one bonus feature compared to JAX-RS Client API. Of course it is providing the same basic HTTP client mentioned in chapter \ref{client-api}. The additional feature is RESTEasy Proxy Framework\footnote{\url{http://docs.jboss.org/resteasy/docs/3.0.9.Final/userguide/html_single/index.html\#d4e2143}}. It is the mirror opposite of JAX-RS server-side specification, meaning the client framework builds a HTTP request that it uses to invoke on a remote RESTful web service, which also doesn't have to JAX-RS service but can be any web resource accepting HTTP requests. To use this client, user must create Java interface with JAX-RS annotations on methods and then use Client API capable invoking proxy methods on specified interface\cite{resteasy-doc}. More detail about this feature can be found in RESTEasy documentation. 

To use this feature in component, user must specify the created interface with fully quantified name in URI option \textit{proxyClientClass} and provide, which method of the interface should be invoked in URI option \textit{proxyMethod}. In reality process() method doesn't have any Client logic implementation in it. Its task is to just select which type of client will be executed depending on provided configuration of endpoint. The real implementation logic of transforming Messages to HTTP requests and HTTP response to Messages is done in implementation of ResteasyHttpBinding interface. In it is also implemented creation of client request and its execution.


\section{ResteasyHttpBinding class}
As already mentioned the ResteasyHttpBinding interface and its implementation DefaultResteasyHttpBinding are responsible for conversion of Messages to HTTP requests and HTTP responses to Messages. It is used only in Producer class. 

These classes contains only 4 methods, where one is just a setter. There is method for populating Exchange from HTTP response and two methods for populating HTTP request from Exchange, depending if the basic client is used or the proxy one. Important aspect of transformation between Exchanges and HTTP requests and responses, is that all headers are extracted and stored between these objects. This is done in both ways of the transformation. Headers are also all filtered by given strategy. The component provides default strategy for filtration named ResteasyHeaderFilterStrategy, but users also can create their own strategy and set on the endpoint as URI option.

There is also a possibility to create own implementation of ResteasyHttpBinding and set it in the component instead the default one provided by the component. This gives user more flexibility if there is some special task that needs to be done and default implementation can't handle it correctly.  

\section{Unit tests}
As already mentioned, RESTEasy can only run in container, where the \textit{.war} application is deployed and servlet is created. This is most crucial for consumer part of the component, so for testing purposes the component was integrated with Arquillian test framework\footnote{\url{http://arquillian.org/}} to use embedded WildFly 8.2 server in tests. Where each test class starts its own WildFly server and deploys created bundle containing the new component and Camel routes.  

Some units test also leverage CamelTestSupport class, that provides lot of useful methods for testing Camel components. This is mostly done in Producer tests in which Arquillian is integrated CamelTestSupport. Tests also provide example different definitions of Camel routes in XML or in Java language.

Camel has convention for structure of unit tests in which every test class represents scenario and has descriptive self-explaining name. This is done to be much more understandable and clear for outside user. 

%\section{Examples of usage}
%???

\chapter{Conclusion}
The main task of this master's thesis was integration of RESTEasy project with Apache Camel project. This means design and developing new Camel component that should be used for integration of RESTful web service and Camel framework. Another requirement set by thesis description was to provide unit tests. Author should also cooperate with community, develop new Camel component by project development standards and investigate RESTEasy implementation. The thesis should also provides comparison of JAX-RS 1.1 and JAX-RS 2.0 specifications.

The result of this master's thesis is Camel Resteasy component. This new component can be used to connect exposed RESTful web service to the Camel Consumer. Furthermore component's Producer can be used as HTTP client that is based on RESTEasy Client API. Thesis also provides comparison between JAX-RS specifications that can be found in chapter \ref{tech}. 

The source code of the component is included in attachments to this thesis. The source code was also hosted on GitHub\footnote{\url{https://github.com/romanjakubco/camel-resteasy}} during development and the latest version can be found there. It is known that computer software is never absolutely perfect, so there is a high chance that new issues and bugs will be found. This is also reason why GitHub was selected for hosting the source code, it provides useful tools for reporting issues or even submitting fixes by pull requests from other developers.  

As this thesis has also implementation part, it contains the whole source code of Camel Resteasy component. Following Camel project documentation, the skeleton for the component was generated using Maven archetype and the biggest part of the work was integrating RESTEasy into the Camel. Because RESTEasy is different in its approach in creating server for RESTful web services compared to other implementations of JAX-RS specification, not providing other way than creating servlet via web.xml file, the mechanism for connecting the servlet to Consumers and keeping track of all consumers was created. Implementation also leverage already implemented component for HTTP protocol as RESTful web services are based around HTTP. Furthermore, there was need for binding between HTTP messages and messages send in Camel routes on Producer side. The Producer of the component is based on RESTEasy Client API that is providing also additional feature called Proxy Framework described in chapter \ref{impl}. Mechanism for enabling and configuring this feature was developed for Producer part of the component.

The new component also provides documentation of usage on GitHub and source code is also documented. Great advantage of Camel is its strong and vital community that provides examples and answers to various problems on StackOverflow\footnote{\url{http://stackoverflow.com/}}. The RESTEasy project is also well documented and used by community mostly around JBoss projects that also can provide help with various problems.

This component was requested by the community, so there is a effort to submit this component into Apache Camel project but at the moment there is a problem with requirements defined by Camel. One of the requirements for submitting new component into Camel distribution is that all dependencies must be OSGi ready. From various issues found on the web, it seems that RESTEasy has some problems with OSGi environment, mostly in class loading. In different environments like WildFly application server that provides RESTEasy as standard module for creating RESTful web service, the new component works without a problem. This is also demonstrated in unit tests provided with the source code. 

So one of the main goals for the future is to look at RESTEasy in OSGi environment and found a way to make it work correctly. Of course bug fixes should be done as well and as soon as possible. Various improvements and suggestions for new features from community are also welcomed and will be implemented depending on current situation.






%The goal of this thesis is to develop a new component to Apache Camel framework that will integrate RESTEasy library for web services interface with Camel and provide REST interface endpoints. The student will evaluate and compare JAX-RS 1.1 and JAX-RS 2.0 application interface, and support the selected application interface in his implementation. The exposed endpoints will be configured via JAX-RS annotations and endpoint consumer will use client interface provided by RESTEasy library.
%Co-operate with community on exact specification of necessary features and commit a working implementation together with tests and documentation required by project development standards.
%% Lists of tables and figures, glossary, etc.
%%\printindex
%%\printglossary
%%\listoffigures
%%\listoftables

\begingroup
\def\tmpchapter{0}
\renewcommand{\chaptername}{}
\renewcommand{\thechapter}{}
%%\addtocontents{toc}{\setcounter{tocdepth}{-1}}
\chapter{References}
\renewcommand{\chapter}[2]{}% for other classes

\bibliographystyle{plain}
\bibliography{references}

\begin{thebibliography}{}


\bibitem{eip} HOHPE, Gregor and WOLF, Bobby. \textit{Enterprise integration patterns}. Boston: Addison-Wesley, c2003, ISBN 978-0321200686.

\bibitem{camel-in-action} IBSEN, Claus and ANSTEY,Jonathan. \textit{Camel in Action}. Greenwich, Conn.: Manning, c2011, ISBN 19-351-8236-6.

\bibitem{resteasy-book} BURKE, Bill. \textit{RESTful Java with JAX-RS 2.0}. Sebastopol: O'Reilly Media, c2013, ISBN 978-1-449-36134-1

\bibitem{camel-cookbook} CRANTON, Scott and KORAB, Jakub. \textit{Apache Camel Developer's Cookbook}.  Birmingham: Packt publishing, c2013, ISBN 9781782170303.

\bibitem{rest-arch} FIELDING, Roy Thomas. \textit{Architectural Styles and the Design of Network-based Software Architectures}. Doctoral dissertation, University of California, Irvine, 2000. 

\bibitem{camel-web} APACHE. \textit{Apache Camel} [online]. 2004- [cite 2014-12-12]. Available at: \url{http://camel.apache.org/}

\bibitem{camel-dzone} http://java.dzone.com/articles/open-source-integration-apache

\bibitem{camel-exchange} http://camel.apache.org/exchange-pattern.html

\bibitem{camel-comp} http://camel.apache.org/creating-a-new-camel-component.html




\bibitem{jax-1.1} http://www.javaworld.com/article/2073264/jax-rs-1-1--what-s-new-.html
\bibitem{jax-1.1-2} http://www.infoq.com/news/2010/02/javaee6-rest

\bibitem{resteasy-doc}\url{http://docs.jboss.org/resteasy/docs/3.0.9.Final/userguide/html_single/index.html}

\bibitem{jax-wiki} \url{http://en.wikipedia.org/wiki/Java_API_for_RESTful_Web_Services}



\bibitem{java-web} ORACLE. \textit{Java} [online]. \copyright{} 2004- [cite 2014-12-12]. Available at: \url{http://www.java.com/}		

\bibitem{jax-rs-2.0-new} http://www.infoq.com/news/2013/06/Whats-New-in-JAX-RS-2.0

\bibitem{jax-rs-2.0} http://java.dzone.com/articles/whats-new-jax-rs-20 	

\bibitem{cxf-jax} http://cxf.apache.org/docs/jax-rs-basics.html\#JAX-RSBasics-WhatisNewinJAX-RS2.0

%

%
%\bibitem{dzone} DZONE RESEARCH. \textit{Guide to Enterprise Integration} [online]. 2014- [cite 2014-12-14]. Available at: \url{http://www.dzone.com/research/guide-to-enterprise-integration}
%
%%\bibitem{esb} THOMAS, Anne. \texit{https://www.gartner.com/doc/1405237/enterprise-service-bus-definition} [online]. 2007 - [cite 2014-12-14]. Available at: \url{https://www.gartner.com/doc/1405237/enterprise-service-bus-definition}




\end{thebibliography}

\endgroup
%% Additional materials
\appendix

\chapter{Appendix}

\section{Contents of included CD}
\newpage
\section{Examples}
\begin{listing}[ht]
	\inputminted[]{java}{sources/future.java}
	\caption{Future example}
	\label{future}
\end{listing}
\begin{listing}[ht]
	\inputminted[]{java}{sources/callbackClient.java}
	\caption{Callback example}
	\label{callbackClient}
\end{listing}

%TODO
\begin{listing}[ht]
	\inputminted[]{java}{sources/todo.java}
	\caption{Asynchronous server-side}
	\label{async-server}
\end{listing}
\newpage
\section{Class Diagram}
bla
%% End of the whole document
\end{document}